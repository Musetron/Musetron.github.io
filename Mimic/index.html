<!DOCTYPE html><html lang="de">
<head>
<meta charset="UTF-8">
<title>Extreme Audio Effekte</title>
</head>
<body>
<h1>Extreme Effekte + Telefon Filter</h1>
<button id="startBtn">Start</button>
<script>
const startBtn = document.getElementById('startBtn');
let wordCount = 1;startBtn.onclick = async () => {
const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const source = audioCtx.createMediaStreamSource(stream);

let mediaRecorder = new MediaRecorder(stream);
let audioChunks = [];
mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
mediaRecorder.start(100); // kleine Blöcke

const analyser = audioCtx.createAnalyser();
analyser.fftSize = 2048;
source.connect(analyser);
const dataArray = new Uint8Array(analyser.fftSize);

let silenceStart = null;
const SILENCE_THRESHOLD = 5;
const SILENCE_DURATION = 300;

function checkSilence() {
    analyser.getByteTimeDomainData(dataArray);
    let max = 0;
    for (let i = 0; i < dataArray.length; i++) {
        const v = Math.abs(dataArray[i] - 128);
        if (v > max) max = v;
    }

    if (max < SILENCE_THRESHOLD) {
        if (!silenceStart) silenceStart = performance.now();
        else if (performance.now() - silenceStart > SILENCE_DURATION) {
            saveChunk();
            silenceStart = null;
        }
    } else {
        silenceStart = null;
    }
    requestAnimationFrame(checkSilence);
}

checkSilence();

async function saveChunk() {
    if (audioChunks.length === 0) return;
    const blob = new Blob(audioChunks, { type: 'audio/webm' });
    audioChunks = [];

    const arrayBuffer = await blob.arrayBuffer();
    const buffer = await audioCtx.decodeAudioData(arrayBuffer);

    const offlineCtx = new OfflineAudioContext(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
    const src = offlineCtx.createBufferSource();
    src.buffer = buffer;

    // Pitch 6 Halbtöne runter
    src.playbackRate.value = 0.707;

    // Distortion stark
    const distortion = offlineCtx.createWaveShaper();
    distortion.curve = new Float32Array(65536).map((v,i)=>Math.tanh((i-32768)/32768*10)); // härter
    distortion.oversample = '4x';

    // Tremolo aggressiv
    const tremolo = offlineCtx.createGain();
    const lfo = offlineCtx.createOscillator();
    lfo.type = 'sawtooth';
    lfo.frequency.value = 100; // schneller
    const lfoGain = offlineCtx.createGain();
    lfoGain.gain.value = 1.0; // große Amplitude
    lfo.connect(lfoGain);
    lfoGain.connect(tremolo.gain);
    lfo.start();

    // Telefon Bandpass 300-3400 Hz
    const bandpass = offlineCtx.createBiquadFilter();
    bandpass.type = 'bandpass';
    bandpass.frequency.value = 800; // Mittenfrequenz
    bandpass.Q.value = 1.0; // Breite anpassen

    // Verkabelung: src -> distortion -> tremolo -> bandpass -> destination
    src.connect(distortion);
    distortion.connect(tremolo);
    tremolo.connect(bandpass);
    bandpass.connect(offlineCtx.destination);

    src.start();
    const rendered = await offlineCtx.startRendering();

    const crushed = bitcrushBuffer(rendered, 3); // stärkerer Bitcrush (3 Bits)
    const wavBlob = bufferToWave(crushed);
    const url = URL.createObjectURL(wavBlob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'word' + wordCount + '.wav';
    a.click();
    wordCount++;
}

function bitcrushBuffer(buffer, bits) {
    const newBuffer = new AudioBuffer({length: buffer.length, numberOfChannels: buffer.numberOfChannels, sampleRate: buffer.sampleRate});
    const step = Math.pow(0.5, bits);
    for (let c = 0; c < buffer.numberOfChannels; c++) {
        const oldData = buffer.getChannelData(c);
        const newData = newBuffer.getChannelData(c);
        for (let i = 0; i < oldData.length; i++) {
            newData[i] = Math.round(oldData[i]/step)*step;
        }
    }
    return newBuffer;
}

function bufferToWave(abuffer) {
    const numOfChan = abuffer.numberOfChannels;
    const length = abuffer.length * numOfChan * 2 + 44;
    const buffer = new ArrayBuffer(length);
    const view = new DataView(buffer);
    let offset = 0;

    function writeString(s){ for (let i=0;i<s.length;i++) view.setUint8(offset++,s.charCodeAt(i)); }

    writeString('RIFF'); view.setUint32(offset, length-8, true); offset+=4;
    writeString('WAVE'); writeString('fmt '); view.setUint32(offset, 16, true); offset+=4;
    view.setUint16(offset, 1, true); offset+=2;
    view.setUint16(offset, numOfChan, true); offset+=2;
    view.setUint32(offset, abuffer.sampleRate, true); offset+=4;
    view.setUint32(offset, abuffer.sampleRate*numOfChan*2, true); offset+=4;
    view.setUint16(offset, numOfChan*2, true); offset+=2;
    view.setUint16(offset, 16, true); offset+=2;
    writeString('data'); view.setUint32(offset, abuffer.length*numOfChan*2, true); offset+=4;

    for(let i=0;i<abuffer.length;i++){
        for(let ch=0;ch<numOfChan;ch++){
            let sample = abuffer.getChannelData(ch)[i];
            sample = Math.max(-1, Math.min(1, sample));
            view.setInt16(offset, sample<0 ? sample*0x8000 : sample*0x7FFF, true);
            offset+=2;
        }
    }
    return new Blob([buffer], {type:"audio/wav"});
}

};
</script>

</body>
</html>
