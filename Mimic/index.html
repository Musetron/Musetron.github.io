<!DOCTYPE html><html lang="de">
<head>
<meta charset="UTF-8">
<title>Random Wiedergabe</title>
</head>
<body>
<h1>Random Audio Replay</h1>
<button id="startBtn">Start</button>
<script>
const startBtn = document.getElementById('startBtn');startBtn.onclick = async () => {
const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const source = audioCtx.createMediaStreamSource(stream);

const analyser = audioCtx.createAnalyser();
analyser.fftSize = 2048;
source.connect(analyser);
const dataArray = new Uint8Array(analyser.fftSize);

const SILENCE_THRESHOLD = 5;
const SILENCE_DURATION = 300; // ms
let silenceStart = null;
let mediaRecorder = new MediaRecorder(stream);
let audioChunks = [];
let savedWords = []; // Array von AudioBuffer

mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
mediaRecorder.start(100);

function checkSilence() {
    analyser.getByteTimeDomainData(dataArray);
    let max = 0;
    for (let i = 0; i < dataArray.length; i++) {
        const v = Math.abs(dataArray[i] - 128);
        if (v > max) max = v;
    }

    if (max < SILENCE_THRESHOLD) {
        if (!silenceStart) silenceStart = performance.now();
        else if (performance.now() - silenceStart > SILENCE_DURATION) {
            saveWord();
            silenceStart = null;
        }
    } else {
        silenceStart = null;
    }

    // Zufällig selbst abspielen
    if (Math.random() < 0.001 && savedWords.length > 0) { // sehr selten
        playRandomWords();
    }

    requestAnimationFrame(checkSilence);
}

checkSilence();

async function saveWord() {
    if (audioChunks.length === 0) return;
    const blob = new Blob(audioChunks, { type: 'audio/webm' });
    audioChunks = [];

    const arrayBuffer = await blob.arrayBuffer();
    const buffer = await audioCtx.decodeAudioData(arrayBuffer);

    // Effekte anwenden (z.B. Distortion, Pitch, Bitcrush, Tremolo)
    const processed = await applyEffects(buffer, audioCtx);

    savedWords.push(processed);

    // Sofort abspielen: zufällige Reihenfolge 1-3 Wörter
    playRandomWords();
}

async function applyEffects(buffer, context) {
    const offlineCtx = new OfflineAudioContext(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
    const src = offlineCtx.createBufferSource();
    src.buffer = buffer;

    // Pitch Down
    src.playbackRate.value = 0.707;

    // Distortion
    const distortion = offlineCtx.createWaveShaper();
    distortion.curve = new Float32Array(65536).map((v,i)=>Math.tanh((i-32768)/32768*10));
    distortion.oversample = '4x';

    // Tremolo
    const tremolo = offlineCtx.createGain();
    const lfo = offlineCtx.createOscillator();
    lfo.type = 'sawtooth';
    lfo.frequency.value = 100;
    const lfoGain = offlineCtx.createGain();
    lfoGain.gain.value = 1.0;
    lfo.connect(lfoGain);
    lfoGain.connect(tremolo.gain);
    lfo.start();

    // Telefon Bandpass
    const bandpass = offlineCtx.createBiquadFilter();
    bandpass.type = 'bandpass';
    bandpass.frequency.value = 800;
    bandpass.Q.value = 1.0;

    src.connect(distortion);
    distortion.connect(tremolo);
    tremolo.connect(bandpass);
    bandpass.connect(offlineCtx.destination);

    src.start();
    const rendered = await offlineCtx.startRendering();
    return rendered;
}

function playRandomWords() {
    if (savedWords.length === 0) return;
    const numWords = Math.floor(Math.random() * 3) + 1; // 1-3 Wörter
    let time = audioCtx.currentTime;
    for (let i = 0; i < numWords; i++) {
        const wordBuffer = savedWords[Math.floor(Math.random() * savedWords.length)];
        const src = audioCtx.createBufferSource();
        src.buffer = wordBuffer;
        src.connect(audioCtx.destination);
        src.start(time);
        // zufällige Pause zwischen 0-500ms
        time += wordBuffer.duration + Math.random() * 0.5;
    }
}

};
</script>

</body>
</html>
