<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Delay Lama</title>
<style>
html, body {
  margin:0; padding:0; width:100%; height:100%;
  background:#111;
  display:flex; flex-direction:column;
  justify-content:flex-end; align-items:center;
  overflow:hidden;
}

#playArea {
  width:80%; height:300px;
  background:#222; border:2px solid #fff;
  border-radius:12px; position:relative;
  margin-bottom:20px; overflow:hidden;
  cursor:pointer;
}

#playArea canvas{
  position:absolute; top:0; left:0;
  pointer-events:none;
}

.lama{
  position:absolute; top:20px;
  left:50%; transform:translateX(-50%);
  background-image:url('./DelayLama.png');
  background-repeat:no-repeat;
  image-rendering:pixelated;
  pointer-events:none;
}
</style>
</head>
<body>

<div id="playArea"></div>
<div class="lama" id="lama"></div>

<script>
// ================= GLOBAL =================
let audioCtx=null, osc1=null, osc2=null, gainNode=null, filters=[];
const C2=65.41, C3=130.81;
const vowels=['I','E','A','U','O'];
const vowelFormants={
  A: [700, 1100, 2950],
  E: [450, 1600, 2600],
  I: [300, 1800, 2850],
  O: [400, 750, 2900],
  U: [275, 650, 2600]
};

const playArea=document.getElementById('playArea');
const lama=document.getElementById('lama');

// Vibrato Parameter
const vibratoDepth = 5;   // maximale Abweichung in Hz
const vibratoSpeed = 6;   // Hz
let vibratoStartTime = 0;
let vibratoAmplitude = vibratoDepth; // Dynamisch je nach X-Position

// üö´ Rechtsklick deaktivieren
playArea.addEventListener('contextmenu',e=>e.preventDefault());

// ================= AUDIO =================
function startAudio(x,y){
  if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)();
  audioCtx.resume();

  if(osc1) stopAudio();

  osc1=audioCtx.createOscillator();
  osc2=audioCtx.createOscillator();
  osc1.type=osc2.type='sawtooth'; osc2.detune.value=3;

  gainNode=audioCtx.createGain(); gainNode.gain.value=0;

  filters=[];
  for(let i=0;i<3;i++){
    const f=audioCtx.createBiquadFilter(); f.type='bandpass'; f.Q.value=20;
    filters.push(f);
  }

  const merger=audioCtx.createGain();
  osc1.connect(merger); osc2.connect(merger);

  filters.forEach(f=>{
    merger.connect(f);
    f.connect(gainNode);
  });
  gainNode.connect(audioCtx.destination);

  osc1.start(); osc2.start();

  updatePitch(x); updateFormants(y);
  gainNode.gain.linearRampToValueAtTime(0.6,audioCtx.currentTime+0.05);

  // Vibrato starten
  vibratoStartTime = audioCtx.currentTime;
  updateVibratoAmplitude(x);
  applyVibrato();
}

function stopAudio(){
  if(!osc1) return;
  gainNode.gain.linearRampToValueAtTime(0,audioCtx.currentTime+0.02);
  setTimeout(()=>{
    if(osc1){ osc1.stop(); osc2.stop(); }
    if(osc1){ osc1.disconnect(); osc2.disconnect(); }
    filters.forEach(f=>f.disconnect());
    gainNode.disconnect();
    osc1=osc2=null; filters=[];
  },30);
}

function updatePitch(x){
  const rect=playArea.getBoundingClientRect();
  const ratio=Math.min(Math.max((x-rect.left)/rect.width,0),1);
  const freq=C2+(C3-C2)*ratio;
  if(osc1){ osc1.frequency.value=freq; osc2.frequency.value=freq; }
}

function updateFormants(y){
  const rect=playArea.getBoundingClientRect();
  const ratio=Math.min(Math.max((y-rect.top)/rect.height,0),1);
  const idx=ratio*(vowels.length-1);
  const l=Math.floor(idx), u=Math.min(l+1,vowels.length-1);
  const t=idx-l;
  for(let i=0;i<3;i++){
    const freq=vowelFormants[vowels[l]][i]*(1-t)+vowelFormants[vowels[u]][i]*t;
    filters[i].frequency.setTargetAtTime(freq,audioCtx.currentTime,0.01);
  }
}

// ================= VIBRATO =================
function updateVibratoAmplitude(x){
  const rect = playArea.getBoundingClientRect();
  const ratio = Math.min(Math.max((x - rect.left)/rect.width,0),1);
  vibratoAmplitude = vibratoDepth * ratio; // links 0, rechts volle Tiefe
}

function applyVibrato(){
  if(!osc1) return;
  const now = audioCtx.currentTime - vibratoStartTime;
  const vibratoValue = Math.sin(now * 2 * Math.PI * vibratoSpeed) * vibratoAmplitude;
  osc1.frequency.value += vibratoValue;
  osc2.frequency.value += vibratoValue;
  requestAnimationFrame(applyVibrato);
}

// ================= LAMA =================
const img=new Image();
img.src='./DelayLama.png';

img.onload=()=>{
  const cols=5, rows=6, fw=img.width/cols, fh=img.height/rows;
  lama.style.width=fw+'px'; lama.style.height=fh+'px';

  let mouseDown=false, lastY=0, idleFrame=0, lastIdleUpdate=0;

  function setFrame(f){
    const z=f-1, row=z%rows, col=Math.floor(z/rows);
    lama.style.backgroundPosition=`-${col*fw}px -${(rows-1-row)*fh}px`;
  }

  function getFrameFromY(y, now){
    const rect=playArea.getBoundingClientRect();
    let r=1-((y-rect.top)/rect.height); r=Math.max(0,Math.min(1,r));

    if(mouseDown){
      if(r<=0.25) return 12-Math.floor(r/0.25*6);
      else if(r<=0.5) return 18-Math.floor((r-0.25)/0.25*6);
      else if(r<=0.75) return 24-Math.floor((r-0.5)/0.25*6);
      else return 30-Math.floor((r-0.75)/0.25*6);
    } else {
      if(now - lastIdleUpdate > 250){ idleFrame++; lastIdleUpdate=now; }
      return (idleFrame%6)+1;
    }
  }

  function animate(now){
    const frame=getFrameFromY(lastY, now);
    setFrame(frame);
    requestAnimationFrame(animate);
  }

  requestAnimationFrame(animate);

  // Event Listeners
  playArea.addEventListener('mousedown',e=>{
    mouseDown=true; lastY=e.clientY;
    startAudio(e.clientX,e.clientY);
  });

  document.addEventListener('mouseup',()=>{
    if(mouseDown){ mouseDown=false; stopAudio(); }
  });

  playArea.addEventListener('mousemove',e=>{
    if(mouseDown){
      lastY=e.clientY;
      updatePitch(e.clientX);
      updateFormants(e.clientY);
      updateVibratoAmplitude(e.clientX); // Dynamische Vibrato-Lautst√§rke
    }
  });
};

// ================= CANVAS =================
const canvas=document.createElement('canvas');
playArea.appendChild(canvas);
const ctx=canvas.getContext('2d');

function resizeCanvas(){
  const rect=playArea.getBoundingClientRect();
  canvas.width=rect.width; canvas.height=rect.height;
  drawKeyboardStripes();
}

function drawKeyboardStripes(){
  const numKeys = 13;
  const whiteKeys = [0,2,4,5,7,9,11,12];
  const keyWidth = canvas.width / numKeys;

  ctx.clearRect(0,0,canvas.width,canvas.height);

  for(let i=0;i<numKeys;i++){
    ctx.fillStyle = whiteKeys.includes(i) ? 'rgba(255,255,255,0.15)' : 'rgba(0,0,0,0.4)';
    ctx.fillRect(i*keyWidth, 0, keyWidth, canvas.height);

    if(i<numKeys-1){
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo((i+1)*keyWidth, 0);
      ctx.lineTo((i+1)*keyWidth, canvas.height);
      ctx.stroke();
    }
  }
}

resizeCanvas();
window.addEventListener('resize',resizeCanvas);
</script>

</body>
</html>
