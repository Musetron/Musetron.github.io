<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Pointcloud Spectrogram Visualizer — Live Mikrofon</title>
  <style>
    html,body{height:100%;margin:0;background:#1a1a1a;color:#ddd;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
    #ui{position:fixed;left:12px;top:12px;z-index:5;background:rgba(0,0,0,0.4);padding:8px;border-radius:8px}
    label{display:block;font-size:12px;margin-bottom:6px}
    .btn{padding:6px 10px;border-radius:6px;border:1px solid rgba(255,255,255,0.08);background:rgba(255,255,255,0.02);color:#fff;cursor:pointer}
    #credits{position:fixed;right:12px;bottom:12px;font-size:12px;opacity:0.7}
  </style>
</head>
<body>
  <div id="ui">
    <button id="startBtn" class="btn">Mikrofon starten</button>
    <label>FFT Größe: <select id="fftSelect"><option>1024</option><option selected>2048</option><option>4096</option></select></label>
    <label>Punkte pro Frame: <input id="binsRange" type="range" min="64" max="2048" value="512"></label>
    <label>Depth (Zeit): <input id="depthRange" type="range" min="16" max="512" value="128"></label>
    <label>Point Size: <input id="sizeRange" type="range" min="0.5" max="6" step="0.1" value="1.8"></label>
  </div>
  <div id="credits">3D Pointcloud Spectrogram — live from your microphone</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>

  <script>
  let renderer, scene, camera, controls;
  let particleSystem, positions, colors;
  let WIDTH = window.innerWidth, HEIGHT = window.innerHeight;

  let audioContext, analyser, sourceNode;
  let freqData;

  let BINS = 512;
  let DEPTH = 128;
  let POINT_SIZE = 1.8;

  let framesBuffer;

  function initThree(){
    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(WIDTH, HEIGHT);
    document.body.appendChild(renderer.domElement);

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x333333); // dunkelgrau Hintergrund

    camera = new THREE.PerspectiveCamera(60, WIDTH/HEIGHT, 0.1, 1000);
    camera.position.set(0, 30, 120);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.2));
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(10,30,10);
    scene.add(dir);

    window.addEventListener('resize', onWindowResize);
  }

  function onWindowResize(){
    WIDTH = window.innerWidth; HEIGHT = window.innerHeight;
    camera.aspect = WIDTH/HEIGHT; camera.updateProjectionMatrix();
    renderer.setSize(WIDTH, HEIGHT);
  }

  function createPointCloud(){
    if (particleSystem) scene.remove(particleSystem);

    const total = BINS * DEPTH;
    const geometry = new THREE.BufferGeometry();

    positions = new Float32Array(total * 3);
    colors = new Float32Array(total * 3);

    const X_RANGE = 100;
    const Z_SPACING = 0.6;

    let idx = 0;
    for(let z=0; z<DEPTH; z++){
      for(let x=0; x<BINS; x++){
        const px = (x / (BINS-1) - 0.5) * X_RANGE;
        const py = -10;
        const pz = z * Z_SPACING;
        positions[idx*3+0] = px;
        positions[idx*3+1] = py;
        positions[idx*3+2] = pz;

        // Schwarze Punkte
        colors[idx*3+0] = 0;
        colors[idx*3+1] = 0;
        colors[idx*3+2] = 0;

        idx++;
      }
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3).setUsage(THREE.DynamicDrawUsage));
    geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage));

    const material = new THREE.ShaderMaterial({
      transparent: true,
      depthTest: true,
      uniforms: {
        uPixelRatio: { value: window.devicePixelRatio },
        uSize: { value: POINT_SIZE }
      },
      vertexShader: `
        attribute vec3 customColor;
        varying vec3 vColor;
        uniform float uPixelRatio;
        uniform float uSize;
        void main(){
          vColor = customColor;
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_PointSize = max(1.0, uPixelRatio * uSize);
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        varying vec3 vColor;
        void main(){
          float r = length(gl_PointCoord - vec2(0.5));
          float alpha = smoothstep(0.5, 0.45, r);
          gl_FragColor = vec4(vColor, alpha);
        }
      `
    });

    particleSystem = new THREE.Points(geometry, material);
    particleSystem.rotation.x = -Math.PI/12;
    scene.add(particleSystem);
  }

  async function initAudio(){
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    sourceNode = audioContext.createMediaStreamSource(stream);

    analyser = audioContext.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.3;
    sourceNode.connect(analyser);

    freqData = new Float32Array(analyser.frequencyBinCount);

    DEPTH = parseInt(document.getElementById('depthRange').value,10);
    BINS = parseInt(document.getElementById('binsRange').value,10);
    framesBuffer = new Array(DEPTH);
    for(let i=0;i<DEPTH;i++) framesBuffer[i] = new Float32Array(BINS);

    createPointCloud();
    animate();
  }

  function pushFrame(){
    const rawBins = new Float32Array(analyser.frequencyBinCount);
    analyser.getFloatFrequencyData(rawBins);

    const step = Math.max(1, Math.floor(rawBins.length / BINS));
    const frame = new Float32Array(BINS);
    for(let i=0, j=0; i<BINS; i++, j+=step){
      const v = rawBins[Math.min(j, rawBins.length-1)];
      let amp = Math.max(0, (v + 100) / 100);
      // nur Hälfte des Pegels anzeigen
      amp = amp * 0.5;
      frame[i] = amp;
    }
    framesBuffer.pop();
    framesBuffer.unshift(frame);
  }

  function updateGeometry(){
    if(!positions) return;
    const X_RANGE = 100;
    const Z_SPACING = 0.6;

    let idx = 0;
    for(let z=0; z<DEPTH; z++){
      const frame = framesBuffer[z];
      for(let x=0; x<BINS; x++){
        const baseIdx = idx*3;
        positions[baseIdx+0] = (x / (BINS-1) - 0.5) * X_RANGE;
        const a = frame ? frame[x] : 0;
        positions[baseIdx+1] = a * 60 - 10;
        positions[baseIdx+2] = z * Z_SPACING;

        colors[baseIdx+0] = 0;
        colors[baseIdx+1] = 0;
        colors[baseIdx+2] = 0;

        idx++;
      }
    }

    particleSystem.geometry.attributes.position.needsUpdate = true;
    particleSystem.geometry.attributes.customColor.needsUpdate = true;
  }

  function animate(){
    requestAnimationFrame(animate);
    if(analyser){
      pushFrame();
      updateGeometry();
    }
    if (controls) controls.update();
    renderer.render(scene, camera);
  }

  document.getElementById('startBtn').addEventListener('click', async ()=>{
    const fftVal = parseInt(document.getElementById('fftSelect').value,10);
    BINS = parseInt(document.getElementById('binsRange').value,10);
    DEPTH = parseInt(document.getElementById('depthRange').value,10);
    POINT_SIZE = parseFloat(document.getElementById('sizeRange').value);

    if(!audioContext){
      try{
        await initAudio();
      }catch(e){
        alert('Konnte Mikrofon nicht öffnen: ' + e.message);
        return;
      }
    }
    analyser.fftSize = fftVal;
    freqData = new Float32Array(analyser.frequencyBinCount);

    framesBuffer = new Array(DEPTH);
    for(let i=0;i<DEPTH;i++) framesBuffer[i] = new Float32Array(BINS);

    createPointCloud();
  });

  document.getElementById('binsRange').addEventListener('change', ()=>{
    BINS = parseInt(document.getElementById('binsRange').value,10);
    framesBuffer = new Array(DEPTH);
    for(let i=0;i<DEPTH;i++) framesBuffer[i] = new Float32Array(BINS);
    createPointCloud();
  });

  document.getElementById('depthRange').addEventListener('change', ()=>{
    DEPTH = parseInt(document.getElementById('depthRange').value,10);
    framesBuffer = new Array(DEPTH);
    for(let i=0;i<DEPTH;i++) framesBuffer[i] = new Float32Array(BINS);
    createPointCloud();
  });

  document.getElementById('sizeRange').addEventListener('input', ()=>{
    POINT_SIZE = parseFloat(document.getElementById('sizeRange').value);
    if(particleSystem) particleSystem.material.uniforms.uSize.value = POINT_SIZE;
  });

  initThree();
  framesBuffer = new Array(DEPTH);
  for(let i=0;i<DEPTH;i++) framesBuffer[i] = new Float32Array(BINS);
  createPointCloud();
  animate();
  </script>
</body>
  </html>
  
