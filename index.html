<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wolke mit Mikrofonsteuerung und Spirit-Logger</title>
<style>
html,body{height:100%;margin:0;overflow:hidden;}
#cloudCanvas{display:block;width:100vw;height:100vh;}
#recordBtn{
  position:fixed;top:10px;left:10px;padding:10px 20px;font-size:16px;z-index:10;
}
#log{
  position:fixed;top:10px;right:10px;width:320px;height:260px;overflow:auto;
  background:rgba(0,0,0,0.6);color:#0f0;font-family:monospace;font-size:14px;
  padding:5px;border-radius:5px;z-index:10;
}
</style>
</head>
<body>
<button id="recordBtn">Start Recording</button>
<div id="log"></div>
<canvas id="cloudCanvas"></canvas>

<script>
// --- Geisterliste 1-100 ---
const ghosts = [
  "Domovoi (slawischer Hausgeist)","Brownie (schottischer Hausgeist)","Zashiki-warashi (japanischer Kindergeist)",
  "Tomte / Nisse (skandinavischer Hausgeist)","Poltergeist (deutsch/modern)","Kitsune (japanischer Fuchsgeist)",
  "Jinn / Djinn (arabische Folklore)","Churel (indische Folklore)","La Llorona (mexikanischer Geist)","Banshee (irischer Todesschrei)",
  "Pontianak / Kuntilanak (südostasiatischer weiblicher Geist)","Vetala (indische untote Gestalt)","Dullahan (irischer kopfloser Reiter)",
  "Revenant (europäischer Rachegeist)","Sylphen (Luftgeist, westliche Alchemie)","Undine (Wassergeist, mitteleuropäische Folklore)",
  "Salamander (Feuergeist, Alchemie/Europa)","Kobold (deutsch/englische Folklore, schelmisch)","Onryō (japanischer Rachegeist)",
  "Huli Jing (chinesischer Fuchsgeist)","La Mala Hora (mexikanische unheilvolle Gestalt)","Manananggal (philippinischer Vampir-Geist)",
  "Jiangshi (chinesischer „hüpfender“ Zombie)","Gashadokuro (japanischer Riesen-Skelettgeist)","Wraith (britischer Todesgeist)",
  "Bogle (schottischer Kobold/Poltergeist)","Teke Teke (japanischer Rachegeist)","Lutin (französischer Hausgeist/Kobold)",
  "Tikoloshe (südafrikanischer Wasser-/Schabernackgeist)","Pishacha (indischer Dämon/Geist)","Elektromagnetische Resonanzfeldstörung",
  "Quanteninferenz-Spur","Biophotonisches Energiefeld","Magnetische Aura-Anomalie","Ionisierte Luftspirale","Körperschall-Resonanz",
  "Feldfluktuation im Infraschallbereich","Photonische Interferenzerscheinung","Elektrostatik-Wellenfront","Schumannresonanzveränderung",
  "Vortex der Energiecluster","Plasma-Knoten","Infraschall-Oszillation","Kalte Lichtanomalie","Magnetfeld-Fluktuation",
  "Quantum Flux-Spiegelung","Bioplasma-Kondensat","Energie-Gradientenwirbel","EMF-Spike","Neurofeld-Resonanz",
  "Domovoi (zweites Haus)","Brownie (zweites Haus)","Poltergeist (sekundär)","Kitsune (trickreich)","Jinn / Djinn (zweite Form)",
  "Onryō (zweiter Typ)","Revenant (regional)","Banshee (zweites Heulen)","Manananggal (regional)","Jiangshi (lokal)",
  "Elektromagnetische Störung","Plasmawirbel","Ionische Resonanz","Feldanomalie","Vibration in Infraschall",
  "Kalte Lichtspirale","Biophoton-Wirbel","Energieblase","EMF-Interferenz","Magnetfeld-Knoten",
  "Quantenfeld-Spiegelung","Neurofeld-Wirbel","Photonische Welle","Feldfluktuation","Ionisierter Nebel",
  "Elektrostatik-Resonanz","Plasma-Frequenzschwingung","Vortex der kalten Energie","Bioplasma-Spirale","Magnetische Turbulenz",
  "Domovoi (Hausgeist Schutz)","Brownie (Hausgeist Helfer)","Zashiki-warashi (Glücksbringer)","Tomte / Nisse (Schutzgeist Hof)",
  "Poltergeist (aktive Störung)","Kitsune (Fuchsgeist List)","Jinn / Djinn (Feuergeist)","Churel (Rachegeist Frau)",
  "La Llorona (Trauernde Frau)","Banshee (Todesschrei)","Elektromagnetischer Puls","Quanten-Verschränkungsblitz",
  "Biophotonische Explosion","Magnetische Turbulenzspirale","Infraschall-Knoten","Plasmafluktuation",
  "Energie-Cluster-Spike","Neurofeld-Interferenz","Photonische Resonanzblase","Feldanomalie-Resonanz"
];

// --- Spirit-Logger Setup ---
const logDiv = document.getElementById('log');
let recording = false;
let recordInterval = null;
let logLines = [];

function addLogLine(line){
  logLines.push(line);
  if(logLines.length > 20) logLines.shift();
  logDiv.innerText = logLines.join("\n");
}

function saveTxtFile(){
  const blob = new Blob([logLines.join("\n")], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'spirit_log.txt';
  a.click();
  URL.revokeObjectURL(url);
}

document.getElementById('recordBtn').addEventListener('click', ()=>{
  if(recording){
    clearInterval(recordInterval);
    recording = false;
    saveTxtFile();
    document.getElementById('recordBtn').innerText = 'Start Recording';
    addLogLine('Recording stopped, file saved.');
  } else {
    recording = true;
    document.getElementById('recordBtn').innerText = 'Stop Recording';
    addLogLine('Recording started...');
    recordInterval = setInterval(logSpirit, 5000);
  }
});

function logSpirit(){
  const now = new Date().toLocaleTimeString();
  if(Math.random() < 0.3){
    const spirit = Math.floor(Math.random()*100)+1;
    const change = Math.floor(Math.random()*101);
    const ghost = ghosts[Math.floor(Math.random()*ghosts.length)];
    addLogLine(`[${now}] Spirit Pegel: ${spirit} | Change: ${change}% | Möglicher Geist: ${ghost}`);
  } else {
    addLogLine(`[${now}] unklar`);
  }
}

setInterval(()=>{
  const now = new Date().toLocaleTimeString();
  if(Math.random() < 0.3){
    const spirit = Math.floor(Math.random()*100)+1;
    const change = Math.floor(Math.random()*101);
    const ghost = ghosts[Math.floor(Math.random()*ghosts.length)];
    addLogLine(`[${now}] Spirit Pegel: ${spirit} | Change: ${change}% | Möglicher Geist: ${ghost}`);
  } else {
    addLogLine(`[${now}] unklar`);
  }
},5000);

// --- Wolken- und Blinkbildanimation ---
const PARTICLE_SRC='https://i.ibb.co/BHnTHLDB/Add-Text-11-09-09-39-04.png';
const BACKGROUND_SRC='https://i.ibb.co/tMRLBLnR/neon-green-wireframe-grid-room-3d-perspective-background-futuristic-digital-outline-space-geometric.jpg';
const BLINK_IMAGE_SRC='https://i.ibb.co/yc5kSK8v/1762683053390.png';
const canvas=document.getElementById('cloudCanvas');
const ctx=canvas.getContext('2d');
let DPR=Math.max(1,window.devicePixelRatio||1);

function resize(){
  DPR=Math.max(1,window.devicePixelRatio||1);
  canvas.width=Math.floor(window.innerWidth*DPR);
  canvas.height=Math.floor(window.innerHeight*DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize',resize);
resize();

const img=new Image(); img.crossOrigin='anonymous'; img.src=PARTICLE_SRC;
const bg=new Image(); bg.crossOrigin='anonymous'; bg.src=BACKGROUND_SRC;
const blinkImg=new Image(); blinkImg.crossOrigin='anonymous'; blinkImg.src=BLINK_IMAGE_SRC;
let blinkVisible=true;
setInterval(()=>{blinkVisible=!blinkVisible;},1000);

const LAYERS=[
  {count:6,speed:0.06,scaleRange:[1.0,1.5],alpha:0.4,depth:0.6},
  {count:10,speed:0.1,scaleRange:[0.7,1.1],alpha:0.5,depth:0.9},
  {count:14,speed:0.14,scaleRange:[0.5,0.9],alpha:0.6,depth:1.4}
];

let particles=[];
function rand(a,b){return a+Math.random()*(b-a);}
function createParticle(layer){
  const s=rand(layer.scaleRange[0],layer.scaleRange[1]);
  return {x:rand(-200,200),y:rand(-100,100),z:rand(0,400),
          vx:rand(-layer.speed,layer.speed),vy:rand(-0.02,0.02),vz:rand(-0.1,0.1),
          scale:s,baseScale:s,alpha:0,targetAlpha:rand(0.4*layer.alpha,0.8*layer.alpha),
          rot:rand(0,Math.PI*2),rotSpeed:rand(-0.002,0.002),layer,
          life:rand(10000,20000),age:0,fadeDuration:2000};
}
function initParticles(){particles=[];for(const l of LAYERS)for(let i=0;i<l.count;i++)particles.push(createParticle(l));}

img.onload=()=>{initParticles();last=performance.now();requestAnimationFrame(loop);};
img.onerror=()=>{initParticles();last=performance.now();requestAnimationFrame(loop);};

let last=performance.now(),masterAlpha=0;

// --- Mikrofon mit Bandpass 2–5 kHz ---
navigator.mediaDevices.getUserMedia({ audio:true }).then(stream=>{
  const audioCtx=new (window.AudioContext||window.webkitAudioContext)();
  const source=audioCtx.createMediaStreamSource(stream);

  // Bandpass-Filter 2–5 kHz
  const bandpass=audioCtx.createBiquadFilter();
  bandpass.type="bandpass";
  bandpass.frequency.value=3500; // Mittenfrequenz
  bandpass.Q.value=0.7; // etwa 2–5 kHz Bandbreite

  const analyser=audioCtx.createAnalyser();
  analyser.fftSize=512;

  // Verbindung: Mikrofon -> Bandpass -> Analyzer
  source.connect(bandpass);
  bandpass.connect(analyser);

  const dataArray=new Uint8Array(analyser.frequencyBinCount);
  function updateMic(){
    analyser.getByteTimeDomainData(dataArray);
    let sum=0;
    for(let i=0;i<dataArray.length;i++){ const val=(dataArray[i]-128)/128; sum+=val*val; }
    const rms=Math.sqrt(sum/dataArray.length);
    masterAlpha=Math.min(1, rms*5);
    requestAnimationFrame(updateMic);
  }
  updateMic();
}).catch(err=>{console.log("Mikrofon Zugriff verweigert",err); masterAlpha=0.5;});

function project3D(x,y,z){ const fov=800; const scale=fov/(fov+z); return {x:canvas.width/2 + x*scale, y:canvas.height/2 + y*scale, scale:scale}; }

function loop(ts){
  const dt=ts-last; last=ts;
  if(bg.complete&&bg.naturalWidth) ctx.drawImage(bg,0,0,canvas.width,canvas.height);

  for(const layer of LAYERS){
    ctx.globalCompositeOperation='source-over';
    for(const p of particles){
      if(p.layer!==layer)continue;
      p.age+=dt; p.x+=p.vx*1.5*(1/p.layer.depth); p.y+=p.vy*1.5; p.z+=p.vz*1.5; p.rot+=p.rotSpeed;
      if(p.age<p.fadeDuration){p.alpha=(p.age/p.fadeDuration)*p.targetAlpha;}
      else if(p.age>p.life-p.fadeDuration){p.alpha=Math.max(0,p.targetAlpha*((p.life-p.age)/p.fadeDuration));}
      else{p.alpha=p.targetAlpha;}
      const alphaFinal=p.alpha*masterAlpha;
      const proj=project3D(p.x,p.y,p.z);
      const wP=img.width*p.scale*0.45*proj.scale;
      const hP=img.height*p.scale*0.45*proj.scale;
      ctx.save(); ctx.translate(proj.x,proj.y); ctx.rotate(p.rot); ctx.globalAlpha=alphaFinal;
      if(img.complete&&img.naturalWidth) ctx.drawImage(img,-wP/2,-hP/2,wP,hP);
      else{ctx.beginPath();ctx.arc(0,0,40*p.scale*proj.scale,0,Math.PI*2);ctx.fillStyle=`rgba(180,180,180,${alphaFinal})`;ctx.fill();}
      ctx.restore();
      if(p.age>p.life){const idx=particles.indexOf(p);if(idx!==-1)particles[idx]=createParticle(layer);}
    }
  }

  if(blinkVisible && blinkImg.complete && blinkImg.naturalWidth){
    const maxW=canvas.width/2; const maxH=canvas.height/2;
    const ratio=Math.min(maxW/blinkImg.width, maxH/blinkImg.height);
    const w=blinkImg.width*ratio; const h=blinkImg.height*ratio;
    const xPos=canvas.width/8; const yPos=canvas.height - h - canvas.height/8;
    ctx.drawImage(blinkImg,xPos,yPos,w,h);
  }

  requestAnimationFrame(loop);
}
</script>
</body>
  </html>
  
