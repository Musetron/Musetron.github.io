<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>DJ Vinyl</title>
<style>
body { margin:0; background:#111; font-family:sans-serif; user-select:none; overflow:hidden;}
canvas { display:block; margin:0 auto; background:#222; }
#ui { position:absolute; bottom:10px; width:100%; display:flex; justify-content:center; gap:20px;}
button { padding:10px 20px; font-size:16px; background:#333; color:#fff; border:2px solid #ccc; cursor:pointer;}
button.active { background:#0f0; color:#000;}
</style>
</head>
<body>

<input type="file" id="fileInput" accept=".wav" style="display:none">
<canvas id="canvas" width="800" height="600"></canvas>
<div id="ui">
  <button id="loadBtn">Load</button>
  <button id="fadeBtn">Fade</button>
  <button id="invertBtn">Normal</button>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const loadBtn = document.getElementById('loadBtn');
const fadeBtn = document.getElementById('fadeBtn');
const invertBtn = document.getElementById('invertBtn');
const fileInput = document.getElementById('fileInput');

let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let gainNode = audioCtx.createGain();
gainNode.connect(audioCtx.destination);

let audioBuffer = null;
let currentSamplePos = 0;
let rotation = 0;
let rotationSpeed = 0;
let friction = 0.98;
let autoplay = true;
let loop = true;
let fadeSpeed = 0.7;
let volume = 1.0;
let reverseFadeLogic = false;
let fadeActive = false;
let paused = false;

let diskImg = new Image();
diskImg.src = 'https://i.ibb.co/1tMTRJWZ/disc.png';

let mouseDown = false;
let lastMouseX = 0;
let needleX = 0;
let manualControl = false; // NEU: Kontrolle durch Scratchen

// --- WAV Laden ---
loadBtn.addEventListener('click', ()=> {
    fileInput.click();
    if(audioCtx.state === 'suspended') audioCtx.resume();
});
fileInput.addEventListener('change', async e => {
    const file = e.target.files[0];
    if(!file) return;
    const arrayBuffer = await file.arrayBuffer();
    audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
    currentSamplePos = 0;
    rotation = 0;
});

// --- Buttons ---
fadeBtn.addEventListener('click', ()=> fadeActive = !fadeActive);
invertBtn.addEventListener('click', ()=> reverseFadeLogic = !reverseFadeLogic);

// --- Maus Scratching ---
canvas.addEventListener('mousedown', e => { 
    mouseDown = true; 
    manualControl = true; // <<< Scratch aktiv
    lastMouseX = e.offsetX; 
});
canvas.addEventListener('mouseup', e => { 
    mouseDown = false; 
    // sanfter Übergang zurück zu Auto
    setTimeout(()=>manualControl=false, 300); 
});
canvas.addEventListener('mouseleave', e => { 
    mouseDown = false; 
    setTimeout(()=>manualControl=false, 300); 
});
canvas.addEventListener('mousemove', e => {
    if(mouseDown && audioBuffer){
        const dx = e.offsetX - lastMouseX;
        rotationSpeed = dx * 5;
        lastMouseX = e.offsetX;
        currentSamplePos = ((rotation % 360)/360) * audioBuffer.length;
    }
});

// --- Gamepad ---
let gamepadIndex = null;
let zAxis = 0.0;
window.addEventListener("gamepadconnected", e=>gamepadIndex=e.gamepad.index);
window.addEventListener("gamepaddisconnected", e=>gamepadIndex=null);

// --- Audio ScriptProcessorNode ---
let scriptNode = audioCtx.createScriptProcessor(1024, 1, 1);
scriptNode.onaudioprocess = function(e){
    if(!audioBuffer || paused) return;
    const outData = e.outputBuffer.getChannelData(0);
    const channelData = audioBuffer.getChannelData(0);

    let normalSpeed = audioBuffer.length / audioBuffer.duration / audioCtx.sampleRate;
    let rotationSpeedNormal = 360 / (audioBuffer.duration*60);
    let speed = normalSpeed * (rotationSpeed / rotationSpeedNormal);

    for(let i=0;i<outData.length;i++){
        let idx = Math.floor(currentSamplePos);
        if(loop) idx = ((idx % channelData.length)+channelData.length)%channelData.length;
        else idx = Math.min(idx, channelData.length-1);
        outData[i] = channelData[idx]*volume;
        currentSamplePos += speed;
    }

    // Fade Logic
    let targetVolume = (paused || fadeActive) ? (reverseFadeLogic?1:0) : (reverseFadeLogic?0:1);
    volume += (targetVolume - volume) * fadeSpeed;
};
scriptNode.connect(gainNode);

// --- Draw ---
function draw(){
    const sw = canvas.width;
    const sh = canvas.height;
    ctx.fillStyle="#111";
    ctx.fillRect(0,0,sw,sh);

    const waveformH = sh*0.2;
    const midY = waveformH/2;
    if(audioBuffer){
        const data = audioBuffer.getChannelData(0);
        const factor = Math.max(1, data.length/sw);
        ctx.strokeStyle="#ccc";
        for(let x=0;x<sw;x++){
            const idx = Math.floor(x*factor);
            const sample = data[idx]*volume;
            const h = sample*(waveformH/2);
            ctx.beginPath();
            ctx.moveTo(x, midY-h);
            ctx.lineTo(x, midY+h);
            ctx.stroke();
        }
    }

    // Nadel folgt Audio-Position
    if(audioBuffer){
        let pos = currentSamplePos;
        if(loop) pos = ((pos % audioBuffer.length) + audioBuffer.length) % audioBuffer.length;
        needleX = pos / audioBuffer.length * sw;
    } else {
        needleX = 0;
    }
    ctx.strokeStyle="red";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(needleX,0);
    ctx.lineTo(needleX,waveformH);
    ctx.stroke();

    // Disk
    const centerX = sw/2;
    const centerY = sh*0.55;
    const size = Math.min(sw,sh)*0.6;
    ctx.save();
    ctx.translate(centerX,centerY);
    ctx.rotate(rotation*Math.PI/180);
    ctx.drawImage(diskImg,-size/2,-size/2,size,size);
    ctx.restore();

    // Rotation
    if(!paused){
        if(manualControl){
            // Scratch steuert Rotation
            rotation += rotationSpeed;
            rotationSpeed *= 0.9; // etwas mehr Dämpfung für Kontrolle
        } else {
            // Auto-Loop / Gamepad
            if(gamepadIndex!==null && Math.abs(zAxis)>0.01){
                rotationSpeed = zAxis * 150;
            } else if(autoplay && audioBuffer){
                rotationSpeed = 360 / (audioBuffer.duration * 60);
            }
            rotation += rotationSpeed;
            rotationSpeed *= friction;
        }
    }

    // Buttons Feedback
    fadeBtn.classList.toggle('active', fadeActive);
    invertBtn.classList.toggle('active', reverseFadeLogic);

    requestAnimationFrame(draw);
}

// --- Gamepad Polling ---
function pollGamepad(){
    if(gamepadIndex!==null){
        const gp = navigator.getGamepads()[gamepadIndex];
        if(gp){
            zAxis = gp.axes[2]; // Z-Achse
            paused = gp.buttons[0].pressed; // Button A
            fadeActive = gp.buttons[2].pressed; // Button Y
        }
    }
    requestAnimationFrame(pollGamepad);
}

draw();
pollGamepad();
</script>

</body>
</html>
