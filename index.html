<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Spirit-Logger</title>
<style>
Â  html, body {
Â  Â  height: 100%;
Â  Â  margin: 0;
Â  Â  overflow: hidden;
Â  Â  background: #040404;
Â  }
Â  #cloudCanvas {
Â  Â  display: block;
Â  Â  width: 100vw;
Â  Â  height: 100vh;
Â  }
Â  .btn {
Â  Â  position: fixed;
Â  Â  top: 10px;
Â  Â  padding: 10px 16px;
Â  Â  font-size: 15px;
Â  Â  border-radius: 6px;
Â  Â  border: none;
Â  Â  background: #222;
Â  Â  color: #fff;
Â  Â  cursor: pointer;
Â  Â  z-index: 11;
Â  Â  box-shadow: 0 4px 14px rgba(0,0,0,0.6);
Â  }
Â  #recordBtn { left: 10px; }
Â  #gainSliderContainer {
Â  Â  position: fixed;
Â  Â  top: 50%;
Â  Â  left: 10px;
Â  Â  transform: translateY(-50%) rotate(-90deg);
Â  Â  height: 30px;
Â  Â  width: 150px;
Â  Â  z-index: 11;
Â  }
Â  #gainSlider { width: 150px; accent-color: #7CFF7C; }
Â  #info {
Â  Â  position: fixed;
Â  Â  top: 10px;
Â  Â  right: 10px;
Â  Â  width: 380px;
Â  Â  max-width: 45vw;
Â  Â  height: 300px;
Â  Â  overflow: auto;
Â  Â  background: rgba(0,0,0,0.66);
Â  Â  color: #7CFF7C;
Â  Â  font-family: monospace;
Â  Â  font-size: 13px;
Â  Â  padding: 10px;
Â  Â  border-radius: 8px;
Â  Â  z-index: 11;
Â  Â  line-height: 1.3;
Â  }
Â  #status {
Â  Â  position: fixed;
Â  Â  bottom: 12px;
Â  Â  left: 12px;
Â  Â  color: #ccc;
Â  Â  font-family: monospace;
Â  Â  font-size: 13px;
Â  Â  z-index: 11;
Â  Â  background: rgba(0,0,0,0.35);
Â  Â  padding: 6px 10px;
Â  Â  border-radius: 6px;
Â  }
Â  @media (orientation: landscape) and (max-height: 500px) {
Â  Â  #info { top: auto; bottom: 10px; width: 45vw; height: 40vh; font-size: 12px; }
Â  Â  #recordBtn { top: 10px; left: 10px; }
Â  Â  #gainSliderContainer { top: 50%; left: 60px; transform: translateY(-50%) rotate(-90deg); }
Â  }
</style>
</head>
<body>

<button id="recordBtn" class="btn">Save Log</button>
<div id="gainSliderContainer">
Â  <input type="range" id="gainSlider" min="0.1" max="5.0" step="0.05" value="1" />
</div>
<div id="info">Lade List.txtâ€¦</div>
<canvas id="cloudCanvas"></canvas>
<div id="status">Initialisiereâ€¦</div>

<script>
/* =========================
Â  Â Config / Globals
Â  Â ========================= */
const LOG_INTERVAL_MS = 5000;
const STABILITY_WINDOW = 6;
const SMOOTH_ALPHA = 0.12;
const LIST_FILENAME = 'List.txt';

const infoDiv = document.getElementById('info');
const statusDiv = document.getElementById('status');
const recordBtn = document.getElementById('recordBtn');
const gainSlider = document.getElementById('gainSlider');
const canvas = document.getElementById('cloudCanvas');
const ctx = canvas.getContext('2d');

let logLines = [];
function addLogLine(line){
Â  logLines.push(line);
Â  if(logLines.length > 200) logLines.shift();
Â  infoDiv.innerText = logLines.slice(-20).join("\n") || 'Keine Logs';
}
function saveTxtFile(filename='spirit_log.txt'){
Â  const blob = new Blob([logLines.join("\n")], {type:'text/plain'});
Â  const url = URL.createObjectURL(blob);
Â  const a = document.createElement('a');
Â  a.href = url;
Â  a.download = filename;
Â  a.click();
Â  URL.revokeObjectURL(url);
}

/* =========================
Â  Â Liste (Geistertexte)
Â  Â ========================= */
let ghostLines = [];
fetch(LIST_FILENAME)
Â  .then(r => r.ok ? r.text() : Promise.reject('List.txt nicht gefunden'))
Â  .then(text => {
Â  Â  ghostLines = text.split(/\r?\n/);
Â  Â  addLogLine(`List.txt geladen: ${ghostLines.length} Zeilen`);
Â  Â  addLogLine('--- Start Log ---');
Â  })
Â  .catch(err => {
Â  Â  addLogLine('Fehler beim Laden von List.txt.');
Â  Â  addLogLine(String(err));
Â  });

/* =========================
Â  Â Mikrofon & Audioanalyse
Â  Â ========================= */
let audioCtx, analyser, micSource, dataArray;
let gainFactor = 1.0;
let smoothedLevel = 0;
let spiritFloat = 0;
let masterAlpha = 0;
const windowValues = [];

async function initMic(){
Â  try {
Â  Â  const stream = await navigator.mediaDevices.getUserMedia({audio:true});
Â  Â  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
Â  Â  await audioCtx.resume();
Â  Â  micSource = audioCtx.createMediaStreamSource(stream);
Â  Â  analyser = audioCtx.createAnalyser();
Â  Â  analyser.fftSize = 1024;
Â  Â  dataArray = new Float32Array(analyser.fftSize);
Â  Â  micSource.connect(analyser);
Â  Â  addLogLine('ğŸ¤ Mikrofon aktiviert.');
Â  Â  updateAudio();
Â  } catch(err){
Â  Â  addLogLine('âš ï¸ Mikrofonfehler: ' + err);
Â  }
}

function getCurrentLevel(){
Â  if(!analyser) return 0;
Â  analyser.getFloatTimeDomainData(dataArray);
Â  let sum = 0;
Â  for(let i=0;i<dataArray.length;i++) sum += dataArray[i]*dataArray[i];
Â  const rms = Math.sqrt(sum / dataArray.length);
Â  return rms * gainFactor;
}

gainSlider.addEventListener('input', e => {
Â  gainFactor = parseFloat(e.target.value);
Â  statusDiv.innerText = `Mikrofon: aktiv â€¢ Gain: ${gainFactor.toFixed(2)}`;
});

function updateAudio(){
Â  const level = getCurrentLevel();
Â  smoothedLevel = smoothedLevel*(1-SMOOTH_ALPHA) + level*SMOOTH_ALPHA;
Â  spiritFloat = Math.min(100, smoothedLevel * 600);
Â  masterAlpha = Math.min(1, spiritFloat / 100);
Â  windowValues.push(spiritFloat);
Â  if(windowValues.length > STABILITY_WINDOW) windowValues.shift();
Â  requestAnimationFrame(updateAudio);
}

function calcChanceFromWindow(){
Â  if(windowValues.length===0) return 0;
Â  const mx = Math.max(...windowValues);
Â  const mn = Math.min(...windowValues);
Â  const diff = mx - mn;
Â  const threshold = 20;
Â  const raw = 1 - (diff/threshold);
Â  return Math.round(Math.max(0,Math.min(1,raw))*100);
}
function getGhostForSpirit(spirit){
Â  if(!ghostLines.length) return 'Liste nicht geladen';
Â  const idx = Math.min(ghostLines.length-1, Math.floor((spirit/100)*ghostLines.length));
Â  return ghostLines[idx];
}

setInterval(()=>{
Â  if(!audioCtx) return;
Â  const now = new Date();
Â  const spirit = spiritFloat;
Â  const chance = calcChanceFromWindow();
Â  const ghost = getGhostForSpirit(spirit);
Â  addLogLine(`[${now.toLocaleTimeString()}] Spirit Pegel: ${spirit.toFixed(2)} | Chance: ${chance}% | Geist: ${ghost}`);
}, LOG_INTERVAL_MS);

recordBtn.addEventListener('click', ()=>{
Â  saveTxtFile();
Â  addLogLine('Log gespeichert.');
});

/* =========================
Â  Â Canvas / Wolkenanimation + Orb
Â  Â ========================= */
const PARTICLE_SRC='https://i.ibb.co/BHnTHLDB/Add-Text-11-09-09-39-04.png';
const BACKGROUND_SRC='https://i.ibb.co/tMRLBLnR/neon-green-wireframe-grid-room-3d-perspective-background-futuristic-digital-outline-space-geometric.jpg';
const BLINK_IMAGE_SRC='https://i.ibb.co/yc5kSK8v/1762683053390.png';

let DPR = Math.max(1, window.devicePixelRatio || 1);
function resizeCanvas(){
Â  DPR = Math.max(1, window.devicePixelRatio || 1);
Â  canvas.width = Math.floor(window.innerWidth * DPR);
Â  canvas.height = Math.floor(window.innerHeight * DPR);
Â  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const img = new Image(); img.crossOrigin='anonymous'; img.src = PARTICLE_SRC;
const bg = new Image(); bg.crossOrigin='anonymous'; bg.src = BACKGROUND_SRC;
const blinkImg = new Image(); blinkImg.crossOrigin='anonymous'; blinkImg.src = BLINK_IMAGE_SRC;

let blinkVisible = true;
setInterval(()=>{ blinkVisible = !blinkVisible; }, 1000);

const LAYERS = [
Â  {count:6,speed:0.06,scaleRange:[1.0,1.5],alpha:0.4,depth:0.6},
Â  {count:10,speed:0.1,scaleRange:[0.7,1.1],alpha:0.5,depth:0.9},
Â  {count:14,speed:0.14,scaleRange:[0.5,0.9],alpha:0.6,depth:1.4}
];

let particles = [];
function rand(a,b){ return a + Math.random()*(b-a); }
function createParticle(layer){
Â  const s = rand(layer.scaleRange[0], layer.scaleRange[1]);
Â  return {
Â  Â  x: rand(-200,200), y: rand(-100,100), z: rand(0,400),
Â  Â  vx: rand(-layer.speed, layer.speed), vy: rand(-0.02,0.02), vz: rand(-0.1,0.1),
Â  Â  scale: s, alpha:0, targetAlpha: rand(0.4*layer.alpha, 0.8*layer.alpha),
Â  Â  rot: rand(0,Math.PI*2), rotSpeed: rand(-0.002,0.002), layer,
Â  Â  life: rand(10000,20000), age:0, fadeDuration:2000
Â  };
}
function initParticles(){ particles = []; for(const l of LAYERS) for(let i=0;i<l.count;i++) particles.push(createParticle(l)); }

let last = performance.now();
function project3D(x,y,z){
Â  const fov = 800;
Â  const scale = fov / (fov + z);
Â  return { x: canvas.width/2 + x*scale, y: canvas.height/2 + y*scale, scale: scale };
}

/* =========================
Â  Â Orb-Logik mit Fade In/Out
Â  Â ========================= */
function lerp(a,b,t){ return a + (b - a)*t; }
let orb = {
Â  x: canvas.width/2, y: canvas.height/2,
Â  targetX: canvas.width/2, targetY: canvas.height/2,
Â  baseRadius: 35, radius:35, glow:0.7,
Â  mode:'idle', movementType:'circle', targetMovementType:'circle',
Â  angle:0, angleSpeed:0, targetAngleSpeed:0,
Â  radiusTarget:35, radiusSpeed:0.02,
Â  centerX: canvas.width/2, centerY: canvas.height/2,
Â  amplitude:0, targetAmplitude:200,
Â  direction:1, targetDirection:1, time:0,
Â  idleOffset:Math.random()*1000,
Â  trail:[],
Â  noiseX:0, noiseY:0,
Â  noiseSpeedX:0.02 + Math.random()*0.02,
Â  noiseSpeedY:0.015 + Math.random()*0.02,
Â  noiseOffsetX:Math.random()*1000,
Â  noiseOffsetY:Math.random()*1000,
Â  fadeAlpha:1,
Â  fadeTarget:1,
Â  fadeSpeed:0.1
};
const MAX_TRAIL = 30;

function idleAnimation(){
Â  orb.radius = orb.baseRadius + Math.sin(Date.now()*0.005)*5;
Â  orb.glow = 0.7 + Math.random()*0.3;
Â  orb.idleOffset += 0.01;
Â  orb.targetX = orb.centerX + Math.sin(orb.idleOffset)*10;
Â  orb.targetY = orb.centerY + Math.cos(orb.idleOffset*1.2)*10;
}
function movementAnimation(){
Â  orb.angleSpeed = lerp(orb.angleSpeed, orb.targetAngleSpeed, 0.02);
Â  orb.amplitude = lerp(orb.amplitude, orb.targetAmplitude, 0.02);
Â  orb.direction = lerp(orb.direction, orb.targetDirection, 0.02);
Â  orb.radius = lerp(orb.radius, orb.radiusTarget, 0.02);
Â  orb.time += orb.angleSpeed;
Â  let ampX = orb.amplitude*(0.8 + Math.sin(orb.time*0.3)*0.2);
Â  let ampY = orb.amplitude*(0.8 + Math.cos(orb.time*0.3)*0.2);
Â  if(orb.movementType==='circle'){
Â  Â  orb.targetX = orb.centerX + Math.cos(orb.time*2*orb.direction)*ampX;
Â  Â  orb.targetY = orb.centerY + Math.sin(orb.time*2*orb.direction)*ampY;
Â  } else {
Â  Â  orb.targetX = orb.centerX + Math.sin(orb.time*3*orb.direction)*ampX;
Â  Â  orb.targetY = orb.centerY + Math.sin(orb.time*2*orb.direction)*ampY;
Â  }
Â  orb.glow = 0.7 + Math.random()*0.2;
}

function drawOrb(){
Â  if(orb.fadeAlpha < 0.01) return;

Â  // Trail
Â  orb.trail.push({x:orb.x, y:orb.y, radius:orb.radius, alpha:orb.fadeAlpha});
Â  if(orb.trail.length > MAX_TRAIL) orb.trail.shift();
Â  for(let i=0;i<orb.trail.length;i++){
Â  Â  let t = i / orb.trail.length;
Â  Â  let trailOrb = orb.trail[i];
Â  Â  let gradient = ctx.createRadialGradient(trailOrb.x, trailOrb.y, 0, trailOrb.x, trailOrb.y, trailOrb.radius);
Â  Â  gradient.addColorStop(0, `rgba(255,255,255,${0.3*t*trailOrb.alpha})`);
Â  Â  gradient.addColorStop(0.5, `rgba(255,255,255,${0.05*t*trailOrb.alpha})`);
Â  Â  gradient.addColorStop(1, `rgba(255,255,255,0)`);
Â  Â  ctx.fillStyle = gradient;
Â  Â  ctx.beginPath();
Â  Â  ctx.arc(trailOrb.x, trailOrb.y, trailOrb.radius, 0, Math.PI*2);
Â  Â  ctx.fill();
Â  }

Â  // Orb Glow
Â  let pulse = Math.sin(Date.now()*0.02)*0.2;
Â  let alphaGlow = (orb.glow + pulse) * orb.fadeAlpha;
Â  if(alphaGlow < 0.01) return;
Â  let gradient = ctx.createRadialGradient(orb.x, orb.y, 0, orb.x, orb.y, orb.radius);
Â  gradient.addColorStop(0, `rgba(255,255,255,${alphaGlow})`);
Â  gradient.addColorStop(0.5, `rgba(255,255,255,${0.2*orb.fadeAlpha})`);
Â  gradient.addColorStop(1, `rgba(255,255,255,0)`);
Â  ctx.fillStyle = gradient;
Â  ctx.beginPath();
Â  ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI*2);
Â  ctx.fill();
}

function maybeSwitchMode(){
Â  if(Math.random()<0.004){
Â  Â  if(orb.mode==='idle'){
Â  Â  Â  orb.mode='movement';
Â  Â  Â  orb.targetMovementType = Math.random()<0.5?'circle':'figure8';
Â  Â  Â  orb.movementType = orb.targetMovementType;
Â  Â  Â  orb.radiusTarget = 30 + Math.random()*20;
Â  Â  Â  orb.targetAngleSpeed = 0.05 + Math.random()*0.08;
Â  Â  Â  orb.targetAmplitude = 150 + Math.random()*100;
Â  Â  Â  orb.targetDirection = Math.random()<0.5?1:-1;
Â  Â  Â  orb.time = 0;
Â  Â  } else {
Â  Â  Â  orb.mode='idle';
Â  Â  Â  orb.targetAngleSpeed=0;
Â  Â  Â  orb.targetAmplitude=0;
Â  Â  }
Â  }
}

// Orb Fade-In/Out
function updateOrbFade(){
Â  if(Math.random()<0.002 && orb.fadeTarget===1) orb.fadeTarget=0;
Â  else if(Math.random()<0.002 && orb.fadeTarget===0) orb.fadeTarget=1;
Â  orb.fadeAlpha = lerp(orb.fadeAlpha, orb.fadeTarget, orb.fadeSpeed);
}

/* =========================
Â  Â Main Loop
Â  Â ========================= */
function loop(ts){
Â  const dt = ts-last; last=ts;
Â  if(bg.complete && bg.naturalWidth) ctx.drawImage(bg,0,0,canvas.width,canvas.height);
Â  masterAlpha = masterAlpha*(1-0.06)+(Math.min(1,spiritFloat/100))*0.06;

Â  for(const layer of LAYERS){
Â  Â  for(const p of particles){
Â  Â  Â  if(p.layer!==layer) continue;
Â  Â  Â  p.age+=dt;
Â  Â  Â  p.x+=p.vx*1.5*(1/p.layer.depth);
Â  Â  Â  p.y+=p.vy*1.5;
Â  Â  Â  p.z+=p.vz*1.5;
Â  Â  Â  p.rot+=p.rotSpeed;
Â  Â  Â  if(p.age<p.fadeDuration) p.alpha=(p.age/p.fadeDuration)*p.targetAlpha;
Â  Â  Â  else if(p.age>p.life-p.fadeDuration) p.alpha=Math.max(0,p.targetAlpha*((p.life-p.age)/p.fadeDuration));
Â  Â  Â  else p.alpha=p.targetAlpha;
Â  Â  Â  const alphaFinal=p.alpha*masterAlpha;
Â  Â  Â  const proj=project3D(p.x,p.y,p.z);
Â  Â  Â  const wP=img.width*p.scale*0.45*proj.scale;
Â  Â  Â  const hP=img.height*p.scale*0.45*proj.scale;
Â  Â  Â  ctx.save();
Â  Â  Â  ctx.translate(proj.x,proj.y);
Â  Â  Â  ctx.rotate(p.rot);
Â  Â  Â  ctx.globalAlpha=alphaFinal;
Â  Â  Â  if(img.complete&&img.naturalWidth) ctx.drawImage(img,-wP/2,-hP/2,wP,hP);
Â  Â  Â  ctx.restore();
Â  Â  Â  if(p.age>p.life){
Â  Â  Â  Â  const idx=particles.indexOf(p);
Â  Â  Â  Â  if(idx!==-1) particles[idx]=createParticle(layer);
Â  Â  Â  }
Â  Â  }
Â  }

Â  if(blinkVisible && blinkImg.complete && blinkImg.naturalWidth){
Â  Â  const maxW=canvas.width/2; const maxH=canvas.height/2;
Â  Â  const ratio=Math.min(maxW/blinkImg.width,maxH/blinkImg.height);
Â  Â  const w=blinkImg.width*ratio; const h=blinkImg.height*ratio;
Â  Â  const xPos=canvas.width/8; const yPos=canvas.height-h-canvas.height/8;
Â  Â  ctx.drawImage(blinkImg,xPos,yPos,w,h);
Â  }

Â  maybeSwitchMode();
Â  updateOrbFade();
Â  if(orb.mode==='idle') idleAnimation();
Â  else movementAnimation();
Â  orb.noiseOffsetX += orb.noiseSpeedX;
Â  orb.noiseOffsetY += orb.noiseSpeedY;
Â  orb.noiseX = Math.sin(orb.noiseOffsetX)*5;
Â  orb.noiseY = Math.sin(orb.noiseOffsetY)*5;
Â  orb.x = lerp(orb.x, orb.targetX + orb.noiseX, 0.08);
Â  orb.y = lerp(orb.y, orb.targetY + orb.noiseY, 0.08);
Â  drawOrb();

Â  requestAnimationFrame(loop);
}

window.addEventListener('load', ()=>{
Â  initParticles();
Â  requestAnimationFrame(loop);
Â  initMic();
Â  addLogLine('Auto-Start aktiv: Wolken & Mikrofon laufen.');
Â  statusDiv.innerText = `Mikrofon: initialisiert â€¢ Gain: ${gainFactor.toFixed(2)}`;
});

window.addEventListener('resize', ()=>{
Â  resizeCanvas();
Â  orb.centerX = canvas.width/2;
Â  orb.centerY = canvas.height/2;
});
</script>
</body>
</html>
