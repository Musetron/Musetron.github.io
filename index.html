<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Spirit-Logger</title>
<style>
  html,body{height:100%;margin:0;overflow:hidden;background:#040404;}
  #cloudCanvas{display:block;width:100vw;height:100vh;}
  .btn{
    position:fixed;top:10px;padding:10px 16px;font-size:15px;border-radius:6px;border:none;
    background:#222;color:#fff;cursor:pointer;z-index:11;
    box-shadow:0 4px 14px rgba(0,0,0,0.6);
  }
  #recordBtn{left:10px;}
  #calibrateBtn{left:140px;}
  #info{
    position:fixed;top:10px;right:10px;width:380px;max-width:45vw;height:300px;overflow:auto;
    background:rgba(0,0,0,0.66);color:#7CFF7C;font-family:monospace;font-size:13px;
    padding:10px;border-radius:8px;z-index:11;line-height:1.3;
  }
  #status{
    position:fixed;bottom:12px;left:12px;color:#ccc;font-family:monospace;font-size:13px;z-index:11;
    background:rgba(0,0,0,0.35);padding:6px 10px;border-radius:6px;
  }
  small.note{color:#aaa;display:block;margin-top:6px;}
</style>
</head>
<body>

<button id="recordBtn" class="btn">Start Recording</button>
<button id="calibrateBtn" class="btn">Kalibrieren</button>

<div id="info">Lade List.txt…</div>
<canvas id="cloudCanvas"></canvas>
<div id="status">Mikrofon: warten... • Gain: –</div>

<script>
/* =========================
   Config / Globals
   ========================= */
const LOG_INTERVAL_MS = 5000;
const STABILITY_WINDOW = 6;
const SMOOTH_ALPHA = 0.12;
const LIST_FILENAME = 'List.txt';

const infoDiv = document.getElementById('info');
const statusDiv = document.getElementById('status');
const recordBtn = document.getElementById('recordBtn');
const calibrateBtn = document.getElementById('calibrateBtn');
const canvas = document.getElementById('cloudCanvas');
const ctx = canvas.getContext('2d');

let logLines = [];
function addLogLine(line){
  logLines.push(line);
  if(logLines.length > 200) logLines.shift();
  infoDiv.innerText = logLines.slice(-20).join("\n") || 'Keine Logs';
}
function saveTxtFile(filename='spirit_log.txt'){
  const blob = new Blob([logLines.join("\n")], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

/* List.txt laden */
let ghostLines = [];
fetch(LIST_FILENAME)
  .then(r => {
    if(!r.ok) throw new Error('List.txt nicht gefunden');
    return r.text();
  })
  .then(text => {
    ghostLines = text.split(/\r?\n/);
    addLogLine(`List.txt geladen: ${ghostLines.length} Zeilen`);
    addLogLine('--- Start Log ---');
  })
  .catch(err => {
    addLogLine('Fehler beim Laden von List.txt — bitte sicherstellen, dass List.txt im selben Ordner liegt.');
    addLogLine(String(err));
  });

/* =========================
   Mikrofon / Audioanalyse
   ========================= */
let audioCtx, analyser, dataArray, micSource;
let gainFactor = 1;
let smoothedLevel = 0;
let spiritFloat = 0.0;
let masterAlpha = 0.0;
const windowValues = [];

async function initMic(){
  try {
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    audioCtx = new AudioContext();
    micSource = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;
    dataArray = new Float32Array(analyser.fftSize);
    micSource.connect(analyser);
    addLogLine('Mikrofon verbunden.');
  } catch(err){
    addLogLine('Fehler beim Zugriff auf Mikrofon: ' + err);
  }
}

function getCurrentLevel(){
  if(!analyser) return 0;
  analyser.getFloatTimeDomainData(dataArray);
  let sum = 0;
  for(let i=0;i<dataArray.length;i++) sum += dataArray[i]*dataArray[i];
  const rms = Math.sqrt(sum / dataArray.length);
  return rms * gainFactor;
}

/* Kalibrierung: Maximalwert → 0.5 */
async function doCalibrate(){
  if(!analyser){ await initMic(); }
  addLogLine('Kalibrierung läuft (2 Sekunden)...');
  const samples = [];
  const t0 = performance.now();
  while(performance.now() - t0 < 2000){
    samples.push(getCurrentLevel()/gainFactor); // ungegainedes Signal
    await new Promise(r=>setTimeout(r,50));
  }
  const maxVal = Math.max(...samples);
  if(maxVal>0){
    gainFactor = 0.5 / maxVal;
    addLogLine(`Kalibriert. Gain = ${gainFactor.toFixed(3)} (max=${maxVal.toFixed(4)})`);
    statusDiv.innerText = `Mikrofon: bereit • Gain: ${gainFactor.toFixed(3)}`;
  } else {
    addLogLine('Kein Signal während Kalibrierung erkannt.');
  }
}

/* Pegelmessung */
function updateAudio(){
  const level = getCurrentLevel();
  smoothedLevel = smoothedLevel*(1-SMOOTH_ALPHA) + level*SMOOTH_ALPHA;
  spiritFloat = Math.min(100, smoothedLevel * 200);
  masterAlpha = Math.min(1, spiritFloat / 100);
  windowValues.push(spiritFloat);
  if(windowValues.length > STABILITY_WINDOW) windowValues.shift();
  requestAnimationFrame(updateAudio);
}

/* Chanceberechnung */
function calcChanceFromWindow(){
  if(windowValues.length===0) return 0;
  const mx = Math.max(...windowValues);
  const mn = Math.min(...windowValues);
  const diff = mx - mn;
  const threshold = 20;
  const raw = 1 - (diff/threshold);
  return Math.round(Math.max(0,Math.min(1,raw))*100);
}

function getGhostForSpirit(spirit){
  if(!ghostLines || ghostLines.length === 0) return 'Liste nicht geladen';
  const len = ghostLines.length;
  let idx = Math.floor((spirit / 100) * len);
  if(idx < 0) idx = 0;
  if(idx >= len) idx = len - 1;
  return ghostLines[idx];
}

/* Buttons */
let recording = false;
recordBtn.addEventListener('click', async ()=>{
  if(!audioCtx) await initMic();
  recording = !recording;
  recordBtn.innerText = recording ? 'Stop Recording' : 'Start Recording';
  if(recording){
    addLogLine('Recording gestartet.');
    updateAudio();
  } else {
    saveTxtFile();
    addLogLine('Recording gestoppt und Datei gespeichert.');
  }
});
calibrateBtn.addEventListener('click', doCalibrate);

/* Logging (alle 5s) */
setInterval(()=>{
  if(!audioCtx) return;
  const now = new Date();
  const spirit = spiritFloat;
  const chance = calcChanceFromWindow();
  const ghost = getGhostForSpirit(spirit);
  const logLine = `[${now.toLocaleTimeString()}] Spirit Pegel: ${spirit.toFixed(2)} | Chance: ${chance}% | Möglicher Geist: ${ghost}`;
  addLogLine(logLine);
}, LOG_INTERVAL_MS);

/* =========================
   Canvas / Wolken-Animation
   ========================= */
const PARTICLE_SRC='https://i.ibb.co/BHnTHLDB/Add-Text-11-09-09-39-04.png';
const BACKGROUND_SRC='https://i.ibb.co/tMRLBLnR/neon-green-wireframe-grid-room-3d-perspective-background-futuristic-digital-outline-space-geometric.jpg';
const BLINK_IMAGE_SRC='https://i.ibb.co/yc5kSK8v/1762683053390.png';

let DPR = Math.max(1, window.devicePixelRatio || 1);
function resizeCanvas(){
  DPR = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = Math.floor(window.innerWidth * DPR);
  canvas.height = Math.floor(window.innerHeight * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const img = new Image(); img.crossOrigin='anonymous'; img.src = PARTICLE_SRC;
const bg = new Image(); bg.crossOrigin='anonymous'; bg.src = BACKGROUND_SRC;
const blinkImg = new Image(); blinkImg.crossOrigin='anonymous'; blinkImg.src = BLINK_IMAGE_SRC;

let blinkVisible = true;
setInterval(()=>{ blinkVisible = !blinkVisible; }, 1000);

const LAYERS = [
  {count:6,speed:0.06,scaleRange:[1.0,1.5],alpha:0.4,depth:0.6},
  {count:10,speed:0.1,scaleRange:[0.7,1.1],alpha:0.5,depth:0.9},
  {count:14,speed:0.14,scaleRange:[0.5,0.9],alpha:0.6,depth:1.4}
];

let particles = [];
function rand(a,b){ return a + Math.random()*(b-a); }
function createParticle(layer){
  const s = rand(layer.scaleRange[0], layer.scaleRange[1]);
  return {
    x: rand(-200,200), y: rand(-100,100), z: rand(0,400),
    vx: rand(-layer.speed, layer.speed), vy: rand(-0.02,0.02), vz: rand(-0.1,0.1),
    scale: s, baseScale: s, alpha:0, targetAlpha: rand(0.4*layer.alpha, 0.8*layer.alpha),
    rot: rand(0,Math.PI*2), rotSpeed: rand(-0.002,0.002), layer,
    life: rand(10000,20000), age:0, fadeDuration:2000
  };
}
function initParticles(){ particles = []; for(const l of LAYERS) for(let i=0;i<l.count;i++) particles.push(createParticle(l)); }

img.onload = ()=>{ initParticles(); last = performance.now(); requestAnimationFrame(loop); };
img.onerror = ()=>{ initParticles(); last = performance.now(); requestAnimationFrame(loop); };

let last = performance.now();

function project3D(x,y,z){
  const fov = 800;
  const scale = fov / (fov + z);
  return { x: canvas.width/2 + x*scale, y: canvas.height/2 + y*scale, scale: scale };
}

function loop(ts){
  const dt = ts - last; last = ts;
  if(bg.complete && bg.naturalWidth) ctx.drawImage(bg, 0, 0, canvas.width, canvas.height);
  masterAlpha = masterAlpha * (1 - 0.06) + (Math.min(1, spiritFloat/100)) * 0.06;

  for(const layer of LAYERS){
    ctx.globalCompositeOperation = 'source-over';
    for(const p of particles){
      if(p.layer !== layer) continue;
      p.age += dt;
      p.x += p.vx * 1.5 * (1/p.layer.depth);
      p.y += p.vy * 1.5;
      p.z += p.vz * 1.5;
      p.rot += p.rotSpeed;

      if(p.age < p.fadeDuration){
        p.alpha = (p.age / p.fadeDuration) * p.targetAlpha;
      } else if(p.age > p.life - p.fadeDuration){
        p.alpha = Math.max(0, p.targetAlpha * ((p.life - p.age) / p.fadeDuration));
      } else {
        p.alpha = p.targetAlpha;
      }

      const alphaFinal = p.alpha * masterAlpha;
      const proj = project3D(p.x, p.y, p.z);
      const wP = img.width * p.scale * 0.45 * proj.scale;
      const hP = img.height * p.scale * 0.45 * proj.scale;

      ctx.save();
      ctx.translate(proj.x, proj.y);
      ctx.rotate(p.rot);
      ctx.globalAlpha = alphaFinal;
      if(img.complete && img.naturalWidth) ctx.drawImage(img, -wP/2, -hP/2, wP, hP);
      ctx.restore();

      if(p.age > p.life){
        const idx = particles.indexOf(p);
        if(idx !== -1) particles[idx] = createParticle(layer);
      }
    }
  }

  if(blinkVisible && blinkImg.complete && blinkImg.naturalWidth){
    const maxW = canvas.width/2;
    const maxH = canvas.height/2;
    const ratio = Math.min(maxW/blinkImg.width, maxH/blinkImg.height);
    const w = blinkImg.width * ratio;
    const h = blinkImg.height * ratio;
    const xPos = canvas.width/8;
    const yPos = canvas.height - h - canvas.height/8;
    ctx.drawImage(blinkImg, xPos, yPos, w, h);
  }
  requestAnimationFrame(loop);
}

/* Initialstatus */
addLogLine('Bereit. Drücke "Start Recording" oder "Kalibrieren" (Mikrofonzugriff erforderlich).');
statusDiv.innerText = `Mikrofon: warten... • Gain: ${gainFactor.toFixed(3)}`;
</script>
</body>
</html>
