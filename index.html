<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Spirit Energy Viewer — Live Mikrofon</title>
  <style>
    html,body{height:100%;margin:0;background:#222;color:#ddd;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;overflow:hidden}
    #ui{position:fixed;left:12px;top:12px;z-index:5;background:rgba(0,0,0,0.4);padding:8px;border-radius:8px}
    label{display:block;font-size:12px;margin-bottom:6px}
    .btn{padding:6px 10px;border-radius:6px;border:1px solid rgba(255,255,255,0.08);background:rgba(255,255,255,0.02);color:#fff;cursor:pointer}
    #credits{position:fixed;right:12px;bottom:12px;font-size:12px;opacity:0.7}
  </style>
</head>
<body>
  <div id="ui">
    <button id="startBtn" class="btn">Mikrofon starten</button>
    <label>FFT Größe: <select id="fftSelect"><option selected>512</option><option>1024</option><option>2048</option><option>4096</option></select></label>
    <label>Punkte pro Frame: <input id="binsRange" type="range" min="64" max="2048" value="100"></label>
    <label>Depth (Zeit): <input id="depthRange" type="range" min="16" max="512" value="32"></label>
    <label>Point Size: <input id="sizeRange" type="range" min="0.5" max="6" step="0.1" value="0.5"></label>
  </div>
  <div id="credits">Spirit Energy Viewer — live from your microphone</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>

  <script>
  let renderer, scene, camera, controls;
  let particleSystem, positions, colors;
  let WIDTH = window.innerWidth, HEIGHT = window.innerHeight;

  let audioContext, analyser, sourceNode;

  let BINS = 100;
  let DEPTH = 32;
  let POINT_SIZE = 0.5;

  let framesBuffer;
  let particleOffsets;

  function initThree(){
    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(WIDTH, HEIGHT);
    document.body.appendChild(renderer.domElement);

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    // leichter Nebel für Depth Effekt
    scene.fog = new THREE.FogExp2(0x222222, 0.01);

    camera = new THREE.PerspectiveCamera(60, WIDTH/HEIGHT, 0.1, 1000);
    camera.position.set(0, 30, 120);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.2));
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(10,30,10);
    scene.add(dir);

    window.addEventListener('resize', onWindowResize);
  }

  function onWindowResize(){
    WIDTH = window.innerWidth; HEIGHT = window.innerHeight;
    camera.aspect = WIDTH/HEIGHT; camera.updateProjectionMatrix();
    renderer.setSize(WIDTH, HEIGHT);
  }

  function createPointCloud(){
    if (particleSystem) scene.remove(particleSystem);

    const total = BINS * DEPTH;
    const geometry = new THREE.BufferGeometry();

    positions = new Float32Array(total * 3);
    colors = new Float32Array(total * 3);
    particleOffsets = new Float32Array(total * 3);

    const X_RANGE = 100;
    const Z_SPACING = 0.6;

    let idx = 0;
    for(let z=0; z<DEPTH; z++){
      for(let x=0; x<BINS; x++){
        const px = (x / (BINS-1) - 0.5) * X_RANGE;
        const py = -10;
        const pz = z * Z_SPACING;
        positions[idx*3+0] = px;
        positions[idx*3+1] = py;
        positions[idx*3+2] = pz;

        particleOffsets[idx*3+0] = (Math.random()-0.5)*0.2;
        particleOffsets[idx*3+1] = (Math.random()-0.5)*0.2;
        particleOffsets[idx*3+2] = (Math.random()-0.5)*0.2;

        colors[idx*3+0] = 0;
        colors[idx*3+1] = 0;
        colors[idx*3+2] = 0;

        idx++;
      }
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3).setUsage(THREE.DynamicDrawUsage));
    geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage));

    const material = new THREE.ShaderMaterial({
      transparent: true,
      depthTest: true,
      uniforms: {
        uPixelRatio: { value: window.devicePixelRatio },
        uSize: { value: POINT_SIZE }
      },
      vertexShader: `
        attribute vec3 customColor;
        varying vec3 vColor;
        uniform float uPixelRatio;
        uniform float uSize;
        void main(){
          vColor = customColor;
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_PointSize = max(1.0, uPixelRatio * uSize);
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        varying vec3 vColor;
        void main(){
          float r = length(gl_PointCoord - vec2(0.5));
          float alpha = smoothstep(0.5, 0.45, r);
          gl_FragColor = vec4(vColor, alpha);
        }
      `
    });

    particleSystem = new THREE.Points(geometry, material);
    particleSystem.rotation.x = -Math.PI/12;
    scene.add(particleSystem);
  }

  async function initAudio(){
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    sourceNode = audioContext.createMediaStreamSource(stream);

    analyser = audioContext.createAnalyser();
    analyser.fftSize = 512;
    analyser.smoothingTimeConstant = 0.3;
    sourceNode.connect(analyser);

    framesBuffer = new Array(DEPTH);
    for(let i=0;i<DEPTH;i++) framesBuffer[i] = new Float32Array(BINS);

    createPointCloud();
    animate();
  }

  function pushFrame(){
    const rawBins = new Float32Array(analyser.frequencyBinCount);
    analyser.getFloatFrequencyData(rawBins);

    const step = Math.max(1, Math.floor(rawBins.length / BINS));
    const frame = new Float32Array(BINS);
    for(let i=0, j=0; i<BINS; i++, j+=step){
      const v = rawBins[Math.min(j, rawBins.length-1)];
      let amp = Math.max(0, (v + 100) / 100);
      amp = amp * 0.5;
      frame[i] = amp;
    }
    framesBuffer.pop();
    framesBuffer.unshift(frame);
  }

  function updateGeometry(){
    if(!positions) return;
    const X_RANGE = 100;
    const Z_SPACING = 0.6;

    let idx = 0;
    for(let z=0; z<DEPTH; z++){
      const frame = framesBuffer[z];
      for(let x=0; x<BINS; x++){
        const baseIdx = idx*3;
        positions[baseIdx+0] = (x / (BINS-1) - 0.5) * X_RANGE + particleOffsets[baseIdx+0];
        const a = frame ? frame[x] : 0;
        positions[baseIdx+1] = a * 80 - 10 + particleOffsets[baseIdx+1]; // verstärkter Pegel
        positions[baseIdx+2] = z * Z_SPACING + particleOffsets[baseIdx+2];

        colors[baseIdx+0] = 0;
        colors[baseIdx+1] = 0;
        colors[baseIdx+2] = 0;

        // sanftes random Wobbeln, nicht zu weit
        particleOffsets[baseIdx+0] += (Math.random()-0.5)*0.05;
        particleOffsets[baseIdx+1] += (Math.random()-0.5)*0.05;
        particleOffsets[baseIdx+2] += (Math.random()-0.5)*0.05;

        idx++;
      }
    }

    particleSystem.geometry.attributes.position.needsUpdate = true;
    particleSystem.geometry.attributes.customColor.needsUpdate = true;
  }

  function animate(){
    requestAnimationFrame(animate);
    if(analyser){
      pushFrame();
      updateGeometry();
    }
    if (controls) controls.update();
    renderer.render(scene, camera);
  }

  document.getElementById('startBtn').addEventListener('click', async ()=>{
    if(!audioContext){
      try{
        await initAudio();
      }catch(e){
        alert('Konnte Mikrofon nicht öffnen: ' + e.message);
        return;
      }
    }
  });

  initThree();
  framesBuffer = new Array(DEPTH);
  for(let i=0;i<DEPTH;i++) framesBuffer[i] = new Float32Array(BINS);
  createPointCloud();
  animate();
  </script>
</body>
</html>
